#!/usr/bin/env python3
# from typing import *

from collections import defaultdict, deque
import sys

sys.setrecursionlimit(10000000)


class Node:

    def __init__(self, edge, flag) -> None:
        self.edge = edge
        self.flag = flag


class Graph:

    def __init__(self) -> None:
        self.data = defaultdict(lambda: Node([], False))

    def edge(self, a, b):
        self.data[a].edge.append(b)

    def show(self):
        for data in self.data.items():
            print(data)

    def dfs(self, a, b):
        stop = None
        dq = deque()

        def __dfs(a, b):
            nonlocal stop
            nonlocal dq
            nonlocal self

            if not stop:
                dq.append(a)
            if a == b:
                stop = True

            self.data[a].flag = True

            for e in self.data[a].edge:
                if not self.data[e].flag:
                    __dfs(e, b)

            if not stop:
                dq.pop()

            return

        __dfs(a, b)
        return list(dq)


# def solve(N: int, X: int, Y: int, U: List[int], V: List[int]) -> Tuple[List[str], List[str]]:
def solve(N, X, Y, U, V):
    g = Graph()
    for u, v in zip(U, V):
        g.edge(u, v)
        g.edge(v, u)
    return g.dfs(X, Y)


# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    N, X, Y = map(int, input().split())
    U = [None for _ in range(N - 1)]
    V = [None for _ in range(N - 1)]
    for i in range(N - 1):
        U[i], V[i] = map(int, input().split())
    d = solve(N, X, Y, U, V)
    print(*d)


if __name__ == '__main__':
    main()
