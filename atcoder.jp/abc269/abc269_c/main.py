#!/usr/bin/env python3
# from typing import *

# from icecream import ic
import itertools


# def solve(N: int) -> Any:
def solve(N):
    ans = []
    one = [i for i in range(len(bin(N)[2:])) if (N >> i) & 1]
    # ic(bin(N), one)

    for bit in range(1 << len(one)):
        candidate = 0
        for shift in range(len(bin(bit)[2:])):
            if bit >> shift & 1:
                candidate += 1 << one[shift]
        ans.append(candidate)

    # 考えてみればbitの列が降順でソートされているので、
    # 配列の0番目から参照するbit全探索のコードから、
    # 生成される数列が降順なのは明らかだった
    return ans


def solve2(N):
    ans = []
    one = [i for i in range(len(bin(N)[2:])) if (N >> i) & 1]

    for lst in itertools.product((0, 1), repeat=len(one)):
        candidate = 0
        for index, bit in enumerate(reversed(lst)):
            candidate += (1 << one[index]) * bit
        ans.append(candidate)
    return ans


# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    N = int(input())
    ans = solve2(N)
    print(*ans, sep="\n")


if __name__ == '__main__':
    main()
